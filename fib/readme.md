
# 1stコアシミュレータver2.3α, アセンブラ、FPUシミュ，変換ツール
※コメント，ラベルの扱いを変更しました．詳細は注意へ

## 使用方法
### シミュレータ
makeコマンドでmainファイルを作成し、「`./main fib.s`」のように実行ファイルを入力としてください。（複数ファイルで実行する場合は，下記項目注意参照）
なお，バイナリファイルで実行したい場合は，`-b`オプションをつければ実行できます．
`-c1, -c2`のように，`-c[ウェイ数]`のオプションをつけるとキャッシュのウェイ数を変えられます(デフォルトは1)．
その後、以下のコマンドを実行してアセンブリの挙動を確かめられます。
- `a`   ... (all) 全実行
- `nb`  ... (next break) 次のブレークポイントまで実行
- `n ([rr])`   ... (next) 次の命令のみを実行
    - オプションに`-r`, `-rh`などと打つと，次の命令を実行した後に自動で`rr`, `rr -h`を実行します．
- `bs [lineN]` ... (break set) `[lineN]`行目にブレークポイントを追加
- `bl`  ... (break list) ブレークポイントのリストを表示
- `bd [lineN]` ... (break delete) `[lineN]`行目のブレークポイントを削除
- `rr ([regName]) (-[base], -[signed])`  ... (register read) `[regName]`のレジスタを`[base]`進法、符号の有無を`[signed]`で表示。
    - `[regname]` ... デフォルトは全レジスタの表示
    - `[base]`    ... b, o, d, h (デフォルトはd)
    - `[signed]`  ... uで符号なしとして表示（デフォルトは符号付） 

- `rw　[regName] [value] (-[base])`  ... (register write) `[regName]`のレジスタに`[base]`進法で`[value]`の値を書き込む。`[base]`はb, o, d, h (デフォルトはd)から選ぶ。unsignedは実装していません。
    - 浮動小数点レジスタに対しては-fでfloat値を書き込めます
- `c`   ... (cache) キャッシュの情報を表示
- `i`   ... (info) これまでの実行命令数などの情報を表示
- `re`  ... (reset) レジスタ群、ブレークポイント、統計情報などのデータをリセットして初期状態に戻す
- `ba`   ... (back) 1命令もとに戻す（1024回まで）
- `mr [address] ([wordN])` ... `[address]`に位置するメモリからMSB方向へ`[wordN]`ワード（省略した場合、1ワード）のメモリを表示する(16進表示) 
    - `[address]`は`0x`などの接頭辞をつけることで進法を変えられる

#### MMIO
以下のアドレスへのバイトアクセスはMMIOとして解釈されます．
- 0x10000 - 3 ... recvのvalidビット．データが読み込める状態の時1をロードでき, 準備中，あるいはデータがもうないときは0をロードする．書き込みするとエラー．
- 0x10000 - 2 ... recv. ここに`lbu`することでデータを順にロードできる．validが0のときは0をロードする．書き込みするとエラー．
- 0x10000 - 1 ... send. ここに`sb`することで，データを送ることができる．送ったデータはsimulatorを`quit`したのちにdata/output.ppmファイルとして出力される．

### アセンブラ
`make assembler`でassemblerファイルを作り、実行してください。

実行時，出力について次を指定するとその形式で出力されます．
- `-b`   ... (binary) バイナリ形式でファイルに出力されます．

以上で，実行すると，`./test/`内の`.s`ファイルが`.s.out`ファイルとして全てコンパイルされます．


### FPU
`make fpuChecker`でfpuCheckerファイルを作成し、実行してください。ランダムに1000*2の浮動小数点を作り、ともに正規化されており、かつその計算結果が正規化数の時のみ、FPUのシミュレータで計算を実行し、difをとり、表示します。

### 変換ツール
`make tools`でtoolsファイルを作成し，実行してください．変換したい値を入れると，int, float，byte配列に変換した場合と，floatレジスタにロードする命令列を表示します．
    - int値として読み込ませたい時は`-b, -h, -d, -o`などのオプションを指定してください．

## 注意
- g++, makeを実行できる環境が必要です。（aptなどでインストールしてください。）
- intが4バイトであることを暗黙に用いているので注意してください
- ~~nextはコメントやラベルをスキップしていましたが、しないように変更しました。~~
- 命令、float、intは4バイトアラインされたアドレスのみで読み書きできます．
- 特にエントリポイントを指定しない場合，実行時引数で最も先頭のファイルの最初の命令から始めます．
- 複数ファイルでシミュレーションする場合，引数としてファイルを渡す際に，エントリポイントのあるファイルは一番最後に配置してください．
    - アセンブラをそのままつなげて一つのファイルのように扱うので，もしこうしない場合，エントリポイントのあるファイルの全命令を実行後，つぎのファイルの先頭の命令を実行してしまいます．
- コメント，ラベルはnopに変換していましたが，無視するように変更しました．
    - アドレスを用いたジャンプを行っている場合，以前のバージョンと挙動が変わることがあります．

## アセンブリの仕様
- `.global `から始まる文も基本的にはコメントとみなすが，特殊な指令は別
    - `.global	min_caml_start`　という文があれば，その下のアドレスをエントリポイントとして設定する
    - これを使わない場合，先頭には`nop`が追加されます．
- ラベル名に使用可能なのはa-Z, 0-9, 記号は_, .のみ。大文字小文字区別する。
    - ただし，内部ではエントリポイントに`"+ENTRY"`というラベルをつけている
    - 同一ラベルがあった場合、パース時にエラーを吐く
- ラベル名の後ろにはコロンをつける
    - ラベルとコロンの間に空白文字が合ってもよいが、ラベル登録時に空白文字は消す
- 行が空白文字（タブ、半角空白）から始まる場合は命令とみなす
    - インデントの数は自由
- オペコードは小文字のみ
    - 現在対応しているのはadd, addi, nop, beq, blt, jの６つ
- レジスタはx0(zero), x1~x31, pcの32+1個
- シャープの後ろはコメント

## その他留意点
- ALUのオーバーフローは処理しない（RISC-Vの仕様？）
- jalr, jrでのジャンプ先は4バイトアラインしたアドレスしか認めない（simulator.cpp doControlの実装参照）
- `sw`, `lw`などは4バイトアラインされたアドレスを指定しないとエラーをはきます

## todo


## バージョン履歴
- 1.00 ... とりあえずファイルを読み込んでの実行を可能に
- 1.10 ... バグ修正、一部の対話実行機能を追加
- 1.20 ... バグ修正、コアとなる対話機能を実装
- 1.30 ... バグ修正、バック機能追加
- 1.40 ... バグ修正、アセンブラ追加
- 1.50 ... バグ修正、差分表示機能、自動レジスタ表示オプションを追加
- 1.60 ... バグ修正、nextの仕様変更、オプションの追加、GUIとの連携機能追加、アセンブラが1stCore対応
- 1.70 ... バグ修正、メモリのロードストアのシミュレーション、メモリ表示命令、FPUのシミュレータを追加
- 1.80 ... バグ修正，fadd, fsub, fmulが基準クリア，エントリポイント機能を追加
- 1.90 ... バグ修正，浮動小数点命令を可能に，複数ファイルの入力が可能に，アセンブラの仕様修正
- 2.00 ... バグ修正，コメント，ラベルを無視するように
- 2.10 ... バグ修正，fmv, ftoi, itof, floorを追加，変換ツールを追加
- 2.20 ... バグ修正，高速化，バイナリ(?)実行モードを追加
- 2.30 ... バグ修正，MMIO機能を追加
